<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultrafast Optical Modem</title>
    <style>
        :root {
            --bg: #121212;
            --primary: #00ff9d;
            --danger: #ff4444;
            --panel: #1e1e1e;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--bg);
            color: #fff;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent scrolling during fullscreen tx */
        }

        /* --- NAVIGATION & LAYOUT --- */
        .page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        .page.active { display: flex; }

        h1 { margin-bottom: 30px; text-transform: uppercase; letter-spacing: 2px; text-align: center; }

        button {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 30px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
        }

        button:hover { background: var(--primary); color: #000; }
        button:active { transform: scale(0.98); }

        /* --- SENDER INPUT PAGE --- */
        textarea {
            width: 90%;
            max-width: 600px;
            height: 100px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 10px;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        /* --- FULLSCREEN TRANSMISSION OVERLAY --- */
        #tx-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: #000;
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .emitter-container {
            display: flex;
            gap: 20px;
            margin-bottom: 50px;
        }

        .emitter {
            width: 40vw; /* Large boxes */
            height: 40vw;
            max-width: 300px;
            max-height: 300px;
            background: #333;
            border: 4px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: #000;
            font-weight: bold;
        }

        .tx-info {
            color: #888;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        #btn-stop-tx {
            border-color: var(--danger);
            color: var(--danger);
            background: #000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #btn-stop-tx:hover { background: var(--danger); color: #fff; }

        /* Spinner for graceful stop */
        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- RECEIVER PAGE --- */
        #video-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 4/3;
            background: #000;
            border: 2px solid #444;
            overflow: hidden;
        }
        
        video { width: 100%; height: 100%; object-fit: cover; }

        /* Targeting Reticles */
        .roi {
            position: absolute;
            top: 50%; transform: translateY(-50%);
            width: 50px; height: 50px;
            border: 3px solid red;
            box-shadow: 0 0 15px red;
            z-index: 10;
        }
        #roi-left { left: 20%; }
        #roi-right { right: 20%; }

        #rx-status {
            margin-top: 15px;
            font-size: 1.2rem;
            color: #aaa;
        }

        #rx-result {
            margin-top: 10px;
            padding: 15px;
            background: #222;
            border: 1px solid var(--primary);
            width: 90%;
            min-height: 50px;
            word-break: break-all;
            font-size: 1.2rem;
            display: none; /* Hidden until result found */
        }

        canvas { display: none; }
    </style>
</head>
<body>

    <!-- HOME PAGE -->
    <div id="page-home" class="page active">
        <h1>Optical Modem<br>Link</h1>
        <button onclick="navTo('send')">Transmitter Mode</button>
        <button onclick="navTo('receive')">Receiver Mode</button>
    </div>

    <!-- SENDER PAGE -->
    <div id="page-send" class="page">
        <h1>Compose Message</h1>
        <textarea id="tx-input" placeholder="Type message here...">HELLO WORLD</textarea>
        <button onclick="startTransmissionLoop()">START TRANSMISSION</button>
        <button onclick="navTo('home')" style="border-color:#555; color:#aaa; font-size:0.8rem;">Back</button>
    </div>

    <!-- FULLSCREEN TX OVERLAY -->
    <div id="tx-overlay">
        <div class="emitter-container">
            <div id="box-l" class="emitter"></div> <!-- Data -->
            <div id="box-r" class="emitter"></div> <!-- Count -->
        </div>
        <div class="tx-info" id="tx-counter">Waiting...</div>
        
        <button id="btn-stop-tx" onclick="requestStop()">
            STOP TRANSMISSION <div class="spinner" id="stop-spinner"></div>
        </button>
    </div>

    <!-- RECEIVER PAGE -->
    <div id="page-receive" class="page">
        <h1>Receiver</h1>
        <div id="video-container">
            <video id="video" autoplay playsinline></video>
            <div id="roi-left" class="roi"></div>
            <div id="roi-right" class="roi"></div>
        </div>
        <div id="rx-status">Waiting for Signal...</div>
        <div id="rx-result"></div>
        <button onclick="resetReceiver()" id="btn-rescan" style="display:none; margin-top:20px;">SCAN AGAIN</button>
        <button onclick="navTo('home')" style="margin-top:30px; border-color:#555; color:#aaa; font-size:0.8rem;">Back</button>
    </div>

    <canvas id="cvs"></canvas>

    <script>
        // --- CONFIGURATION ---
        const PULSE_TIME = 40; // ms (Speed of light... almost)
        const COLORS = [
            [0,0,0], [255,0,0], [0,255,0], [0,0,255], 
            [255,255,0], [0,255,255], [255,0,255], [255,255,255]
        ]; // 0-7
        const GAP_COLOR = [20, 20, 20]; // Dark grey for "No Data"

        // Markers
        const MARKER_START = { d: 7, c: 7 }; // White/White
        const MARKER_END   = { d: 1, c: 1 }; // Red/Red
        const GAP          = { d: -1, c: -1 };

        // --- GLOBAL VARIABLES ---
        let txInterval;
        let stopRequested = false;
        let stream = null;
        let rxActive = false;
        let rxCompleted = false; // Prevents re-reading
        let rxBuffer = [];
        let rxState = 'IDLE'; // IDLE, READING

        // --- NAVIGATION ---
        function navTo(pageId) {
            // Stop everything
            stopTxImmediate();
            stopCamera();
            
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('page-' + pageId).classList.add('active');

            if(pageId === 'receive') startCamera();
        }

        // --- TRANSMITTER LOGIC ---

        function encode(text) {
            // 1. ASCII to Octal
            let octals = [];
            for(let i=0; i<text.length; i++) {
                let s = text.charCodeAt(i).toString(8).padStart(3,'0');
                s.split('').forEach(x => octals.push(parseInt(x)));
            }
            // 2. RLE Compression
            let packets = [];
            if(octals.length === 0) return [];
            let curr = octals[0], count = 1;
            for(let i=1; i<octals.length; i++) {
                if(octals[i] === curr && count < 7) count++;
                else { packets.push({d: curr, c: count}); curr = octals[i]; count = 1; }
            }
            packets.push({d: curr, c: count});
            return packets;
        }

        function startTransmissionLoop() {
            const text = document.getElementById('tx-input').value;
            if(!text) return alert("Enter text!");
            
            const payload = encode(text);
            
            // Show Overlay
            document.getElementById('tx-overlay').style.display = 'flex';
            document.getElementById('btn-stop-tx').disabled = false;
            document.getElementById('stop-spinner').style.display = 'none';
            stopRequested = false;

            // Build Full Sequence: START -> [Data/Gap...] -> END -> GAP
            // We construct one "Loop Frame".
            let sequence = [];
            
            // Header
            sequence.push(MARKER_START); 
            sequence.push(GAP); sequence.push(GAP); // Extra gap for clear sync

            // Body
            payload.forEach(p => {
                sequence.push(p);
                sequence.push(GAP);
            });

            // Footer
            sequence.push(MARKER_END);
            sequence.push(GAP); sequence.push(GAP);

            let idx = 0;
            const totalPackets = payload.length;
            let dataPacketsSent = 0; // For UI counter

            const boxL = document.getElementById('box-l');
            const boxR = document.getElementById('box-r');
            const counter = document.getElementById('tx-counter');

            txInterval = setInterval(() => {
                const packet = sequence[idx];
                
                // Color update
                if(packet.d === -1) {
                    setBoxColor(boxL, GAP_COLOR);
                    setBoxColor(boxR, GAP_COLOR);
                } else {
                    setBoxColor(boxL, COLORS[packet.d]);
                    setBoxColor(boxR, COLORS[packet.c]);
                    
                    // Update counter only if it's actual data
                    if(packet !== MARKER_START && packet !== MARKER_END) {
                        // We rely on order. 
                        // Visual helper:
                        boxL.innerText = packet.d;
                        boxR.innerText = packet.c;
                    } else {
                        boxL.innerText = (packet === MARKER_START) ? "S" : "E";
                        boxR.innerText = "";
                    }
                }

                // Increment
                idx++;

                // Logic to update UI Packet Counter
                // This is an estimation based on index, as sequence includes gaps
                let currentPayloadIndex = Math.floor((idx - 3) / 2); // approximate
                if(currentPayloadIndex < 0) currentPayloadIndex = 0;
                if(currentPayloadIndex > totalPackets) currentPayloadIndex = totalPackets;
                counter.innerText = `Packet: ${currentPayloadIndex} / ${totalPackets}`;


                // Loop Check
                if (idx >= sequence.length) {
                    idx = 0; // Loop back to start
                    dataPacketsSent = 0;

                    // CHECK FOR STOP REQUEST
                    if (stopRequested) {
                        stopTxImmediate();
                        document.getElementById('tx-overlay').style.display = 'none';
                    }
                }

            }, PULSE_TIME);
        }

        function requestStop() {
            stopRequested = true;
            document.getElementById('btn-stop-tx').disabled = true;
            document.getElementById('stop-spinner').style.display = 'block';
            document.getElementById('tx-counter').innerText = "Finishing current message...";
        }

        function stopTxImmediate() {
            if(txInterval) clearInterval(txInterval);
            document.getElementById('tx-overlay').style.display = 'none';
        }

        function setBoxColor(el, rgb) {
            el.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
            // Contrast text
            el.style.color = (rgb[0] > 100 && rgb[1] > 100) ? 'black' : 'white';
        }

        // --- RECEIVER LOGIC ---

        async function startCamera() {
            resetReceiver();
            const video = document.getElementById('video');
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', frameRate: { ideal: 60 } } 
                });
                video.srcObject = stream;
                rxActive = true;
                requestAnimationFrame(rxLoop);
            } catch (e) { alert("Camera Error"); }
        }

        function stopCamera() {
            rxActive = false;
            if(stream) stream.getTracks().forEach(t => t.stop());
        }

        function resetReceiver() {
            rxBuffer = [];
            rxState = 'IDLE';
            rxCompleted = false;
            document.getElementById('rx-result').style.display = 'none';
            document.getElementById('rx-result').innerText = "";
            document.getElementById('rx-status').innerText = "Align boxes in red squares...";
            document.getElementById('rx-status').style.color = "#aaa";
            document.getElementById('btn-rescan').style.display = 'none';
        }

        let lastPhase = 'GAP'; // GAP or SIGNAL

        function rxLoop() {
            if(!rxActive) return;
            // Stop processing if we already have the message
            if(rxCompleted) {
                requestAnimationFrame(rxLoop); // Keep camera running but don't process
                return; 
            }

            const video = document.getElementById('video');
            const cvs = document.getElementById('cvs');
            const ctx = cvs.getContext('2d');

            if(video.readyState === video.HAVE_ENOUGH_DATA) {
                cvs.width = video.videoWidth;
                cvs.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);

                // ROI Positions (20% from left/right)
                const y = Math.floor(cvs.height / 2);
                const xL = Math.floor(cvs.width * 0.20);
                const xR = Math.floor(cvs.width * 0.80);

                const colL = getColorCode(ctx, xL, y);
                const colR = getColorCode(ctx, xR, y);

                processRxSignal(colL, colR);
            }
            requestAnimationFrame(rxLoop);
        }

        function getColorCode(ctx, x, y) {
            const p = ctx.getImageData(x-10, y-10, 20, 20).data;
            let r=0,g=0,b=0,c=0;
            for(let i=0; i<p.length; i+=4) { r+=p[i]; g+=p[i+1]; b+=p[i+2]; c++; }
            r/=c; g/=c; b/=c;

            // Is it Gap?
            if(dist([r,g,b], GAP_COLOR) < 60) return -1;

            // Closest color
            let minD = 9999, idx = -1;
            COLORS.forEach((col, i) => {
                const d = dist([r,g,b], col);
                if(d < minD) { minD = d; idx = i; }
            });
            return (minD < 100) ? idx : -1;
        }

        function dist(c1, c2) {
            return Math.sqrt((c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2);
        }

        function processRxSignal(L, R) {
            const isGap = (L === -1 || R === -1);

            // Edge Trigger: Only act when we transition GAP -> SIGNAL
            if(lastPhase === 'GAP' && !isGap) {
                
                // 1. Check for START (White/White = 7/7)
                if(L === 7 && R === 7) {
                    rxState = 'READING';
                    rxBuffer = [];
                    document.getElementById('rx-status').innerText = "Receiving Data...";
                    document.getElementById('rx-status').style.color = "#00ff9d";
                    lastPhase = 'SIGNAL';
                    return;
                }

                // 2. Check for END (Red/Red = 1/1)
                if(L === 1 && R === 1) {
                    if(rxState === 'READING') {
                        finishReception();
                    }
                    lastPhase = 'SIGNAL';
                    return;
                }

                // 3. Data Packet
                if(rxState === 'READING') {
                    // L = Octal Digit, R = Count (1-7)
                    let count = R;
                    if(count < 1) count = 1; if(count > 7) count = 7;
                    
                    for(let k=0; k<count; k++) rxBuffer.push(L);
                    
                    document.getElementById('rx-status').innerText = `packets: ${rxBuffer.length}`;
                }
            }

            lastPhase = isGap ? 'GAP' : 'SIGNAL';
        }

        function finishReception() {
            rxCompleted = true; // STOP READING
            rxState = 'IDLE';

            // Decode Buffer
            let msg = "";
            for(let i=0; i<rxBuffer.length; i+=3) {
                if(i+2 < rxBuffer.length) {
                    const oct = "" + rxBuffer[i] + rxBuffer[i+1] + rxBuffer[i+2];
                    msg += String.fromCharCode(parseInt(oct, 8));
                }
            }

            // Display
            const status = document.getElementById('rx-status');
            status.innerText = "Transmission Complete";
            status.style.color = "#fff";

            const resDiv = document.getElementById('rx-result');
            resDiv.style.display = 'block';
            resDiv.innerText = msg;

            document.getElementById('btn-rescan').style.display = 'inline-block';
        }

    </script>
</body>
</html>
