<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>POV Globe - Accel to Gyro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }

        #hud {
            position: absolute;
            top: 20px; left: 20px;
            color: #00ffcc;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #menu {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 10px;
            z-index: 100;
        }

        button {
            background: rgba(0, 255, 204, 0.2);
            color: #00ffcc;
            border: 1px solid #00ffcc;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            font-size: 12px;
            text-transform: uppercase;
        }

        button.active {
            background: #00ffcc;
            color: #000;
        }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; color: white; text-align: center;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <div>
            <h1>POV GLOBE</h1>
            <p>Simulating Gyroscope via Accelerometer</p>
            <button id="startBtn" style="font-size: 20px; padding: 20px 40px;">ENTER GLOBE</button>
        </div>
    </div>

    <div id="hud">
        MODE: <span id="modeDisplay">High Quality</span><br>
        PITCH: <span id="pitch">0</span>°<br>
        ROLL: <span id="roll">0</span>°
    </div>

    <div id="menu">
        <button onclick="setPreset('gyro')">Real Gyro-Like</button>
        <button onclick="setPreset('precise')">Precise</button>
        <button class="active" onclick="setPreset('hq')">High Quality</button>
    </div>

    <!-- Loading Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, globe;
        let currentPitch = 0, currentRoll = 0;
        let targetPitch = 0, targetRoll = 0;
        
        // Physics Presets
        const presets = {
            gyro: { smoothing: 0.2, sensitivity: 1.5, noiseFilter: 0.01 },
            precise: { smoothing: 0.05, sensitivity: 1.0, noiseFilter: 0.05 },
            hq: { smoothing: 0.08, sensitivity: 1.2, noiseFilter: 0.02 }
        };
        let activePreset = presets.hq;

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create the "Globe" environment
            // We use a large sphere and render the inside
            const geometry = new THREE.SphereGeometry(50, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0x111111,
                side: THREE.BackSide,
                wireframe: true // Makes it look like a digital globe
            });
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Add "Dots" (Stars/Particles)
            const dotGeometry = new THREE.BufferGeometry();
            const dotCoords = [];
            for (let i = 0; i < 2000; i++) {
                dotCoords.push((Math.random() - 0.5) * 80);
                dotCoords.push((Math.random() - 0.5) * 80);
                dotCoords.push((Math.random() - 0.5) * 80);
            }
            dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotCoords, 3));
            const dotMaterial = new THREE.PointsMaterial({ color: 0x00ffcc, size: 0.2 });
            const dots = new THREE.Points(dotGeometry, dotMaterial);
            scene.add(dots);

            // Add some floating shapes for depth
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            for(let i=0; i<20; i++) {
                const mesh = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({color: 0x00ffcc, wireframe: true}));
                mesh.position.set((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
                scene.add(mesh);
            }

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Smooth Interpolation (The "Stabilization" logic)
            currentPitch += (targetPitch - currentPitch) * activePreset.smoothing;
            currentRoll += (targetRoll - currentRoll) * activePreset.smoothing;

            // Apply rotation to the camera to simulate looking around
            camera.rotation.set(currentPitch, currentRoll, 0, 'YXZ');

            renderer.render(scene, camera);
        }

        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            if (!acc) return;

            // PRECISE CALCULATION: 
            // Converting Accelerometer Gravity Vectors to Euler Angles (Pitch/Roll)
            // Math.atan2 helps determine the angle of the device relative to the ground
            
            let x = acc.x;
            let y = acc.y;
            let z = acc.z;

            // Calculate Roll (Left/Right tilt)
            let roll = Math.atan2(x, z);
            
            // Calculate Pitch (Up/Down tilt)
            let pitch = Math.atan2(-y, Math.sqrt(x * x + z * z));

            // Noise Filtering: Ignore tiny vibrations
            if (Math.abs(roll) < activePreset.noiseFilter) roll = 0;
            if (Math.abs(pitch) < activePreset.noiseFilter) pitch = 0;

            targetRoll = roll * activePreset.sensitivity;
            targetPitch = pitch * activePreset.sensitivity;

            // Update HUD
            document.getElementById('pitch').innerText = (targetPitch * (180/Math.PI)).toFixed(1);
            document.getElementById('roll').innerText = (targetRoll * (180/Math.PI)).toFixed(1);
        }

        function setPreset(p) {
            activePreset = presets[p];
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('modeDisplay').innerText = event.target.innerText;
        }

        document.getElementById('startBtn').addEventListener('click', async () => {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                const permission = await DeviceMotionEvent.requestPermission();
                if (permission === 'granted') {
                    window.addEventListener('devicemotion', handleMotion);
                }
            } else {
                window.addEventListener('devicemotion', handleMotion);
            }
            document.getElementById('overlay').style.display = 'none';
            init3D();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
