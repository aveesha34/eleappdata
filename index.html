<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hardware Stabilized Camera</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        
        /* The Viewport clips the overflow of the stabilized video */
        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 1.3x zoom provides the 'buffer' needed to move the image without seeing edges */
        video {
            min-width: 100%;
            min-height: 100%;
            object-fit: cover;
            transform: scale(1.3); 
            will-change: transform;
        }

        #ui {
            position: absolute;
            top: 10px; left: 10px;
            color: #0f0; background: rgba(0,0,0,0.7);
            padding: 10px; border-radius: 5px; font-size: 12px;
            z-index: 10; pointer-events: none;
        }

        button {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #fff; border: none;
            border-radius: 50px; font-weight: bold;
            z-index: 20; cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="viewport">
        <video id="cam" autoplay playsinline></video>
    </div>

    <div id="ui">
        <b>STABILIZER ACTIVE (ACCEL ONLY)</b><br>
        X-Offset: <span id="ox">0</span><br>
        Y-Offset: <span id="oy">0</span><br>
        Z-Force: <span id="oz">0</span>
    </div>

    <button id="start">START STABILIZATION</button>

<script>
    const video = document.getElementById('cam');
    const startBtn = document.getElementById('start');
    
    // Stabilization variables
    let baselineX = 0, baselineY = 0;
    let smoothX = 0, smoothY = 0;
    
    // Hyper-parameters for "Professional" feel
    const STRENGTH = 12;      // How aggressively to counter the shake
    const SMOOTHING = 0.08;   // How fast the camera returns to center (0.01 - 0.1)
    const MAX_SHIFT = 60;     // Max pixels to move (prevents "jumping")

    async function start() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', frameRate: { ideal: 60 } } 
            });
            video.srcObject = stream;

            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                const res = await DeviceMotionEvent.requestPermission();
                if (res === 'granted') window.addEventListener('devicemotion', stabilize);
            } else {
                window.addEventListener('devicemotion', stabilize);
            }
            startBtn.style.display = 'none';
        } catch (e) { alert("Camera/Sensor access required."); }
    }

    function stabilize(event) {
        const acc = event.accelerationIncludingGravity;
        if (!acc) return;

        // 1. Update the 'Baseline' (the slow-moving gravity vector)
        // This represents where the phone "wants" to be.
        baselineX = (baselineX * 0.95) + (acc.x * 0.05);
        baselineY = (baselineY * 0.95) + (acc.y * 0.05);

        // 2. Calculate the 'Jitter' (Current - Baseline)
        // If jitter is positive, the phone jerked one way; we move the video the other way.
        let deltaX = (acc.x - baselineX) * STRENGTH;
        let deltaY = (acc.y - baselineY) * STRENGTH;

        // 3. Smooth the counter-movement (Low Pass Filter)
        // This prevents the stabilization itself from looking shaky.
        smoothX += (deltaX - smoothX) * SMOOTHING;
        smoothY += (deltaY - smoothY) * SMOOTHING;

        // 4. Constraints
        smoothX = Math.max(-MAX_SHIFT, Math.min(MAX_SHIFT, smoothX));
        smoothY = Math.max(-MAX_SHIFT, Math.min(MAX_SHIFT, smoothY));

        // 5. Apply the Inverse Transform
        // We use translate3d for GPU acceleration. 
        // We move +X if the phone moves -X to stay "fixed" in space.
        video.style.transform = `scale(1.3) translate3d(${smoothX.toFixed(2)}px, ${-smoothY.toFixed(2)}px, 0)`;

        // Update Logs
        document.getElementById('ox').innerText = Math.round(smoothX);
        document.getElementById('oy').innerText = Math.round(-smoothY);
        document.getElementById('oz').innerText = acc.z.toFixed(2);
    }

    startBtn.onclick = start;
</script>
</body>
</html>
